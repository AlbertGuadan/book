## 24. Challenges to New Dev Process

In the wake of the exodus to Habari, things had already started to change. In March 2007, Robin Adrianse was given commit access for three months to help Ryan Boren address the issue of tickets languishing. He was WordPress’ first temporary committer. 

Also in March, the Plugin Directory was launched. This gave more exposure than ever before to developers using WordPress and it was now easier for users to find plugins.	
<img src="../../Resources/community/plugin-directory-2007.jpg" width="800px" />

Prior to the plugin directory, many developers would just host their plugins on their website. The plugin directory gave them exposure to a huge amount of new users. Samuel Wood ([Otto42](http://profiles.wordpress.org/otto42), recalls how the plugin directory encouraged him to distribute his code. “I was writing them before, but I didn't give them to anybody. It encouraged me to release plugins because I had a place to put them.”	


The development team had also committed to a much faster release cycle. WordPress 2.1 was released in January 2007, more than a year after the start of the release cycle. This long year had dragged on because of the desire to always slip in one more thing. The commitment to the faster release cycle meant that the team had a deadline and no new features could be put in after a certain date. The emergence of this new philosophy, which would later become “deadlines are not arbitrary” in WordPress’ list of philosophies, would be an ongoing challenge. Developing in an open source environment means leaving time for every voice to be heard, waiting for volunteers with busy lives to get things done, spending time discussing new features and architecture changes. It’s a challenge that WordPress would have to address release cycle after release cycle.

And in the 2.2 release cycle, the first cycle with the new 120 day model, this approach would be put to the test in a major way. WordPress 2.2 was to be the release with some of the biggest database architecture change to date - the next taxonomy system.

 In the early 2000s, the internet was rife with discussions about the best way to organise information. Content has metadata assigned to it, that can be used to organise and display data. Traditional modes of classification in the web used top-down methods in which the schema was imposed from above. These structures were often rigid, forcing users to shoehorn their content into something that didn’t necessarily fit. A new method of classification was emerging - tags, a bottom-up of form of classification, in which an index, or a cloud, can be generated based on keywords that the content creator applies to the content.	
The first system to use tags was social bookmarking site [Del.icio.us](https://delicious.com/). While Del.icio.us wasn’t pioneering as a bookmarks manager, it differentiated itself with its tagging system. Users can tag saved links, which are used to relate tags to each other within a user’s collection. They are also used to relate tags to each other across the entire social network, so visiting the link http://delicious.com/tag/php will display all of the links that have been tagged PHP.	
Controlled, top-down, ways of classifying content were failing to scale on large-scale Web 2.0 applications in which millions of users were creating and organising their content. It wasn’t proving to be possible to force users to use controlled vocabularies. [Clay Shirky discussed the problem](http://many.corante.com/archives/2005/01/07/folksonomies_controlled_vocabularies.php):

> users pollute controlled vocabularies, either because they misapply the words, or stretch them to uses the designers never imagined, or because the designers say “Oh, let’s throw in an ‘Other’ category, as a fail-safe” which then balloons so far out of control that most of what gets filed gets filed in the junk drawer. Usenet blew up in exactly this fashion, where the 7 top-level controlled categories were extended to include an 8th, the ‘alt.’ hierarchy, which exploded and came to dwarf the entire, sanctioned corpus of groups.	
The system of classification using mass tagging systems came to be known as a [folksonomy](https://en.wikipedia.org/wiki/Folksonomy). This is a classification system in which users classifying content themselves. 	
In 2005, Technorati, the blog search engine, [launched its own tagging system](http://www.sifry.com/alerts/archives/000270.html). This created a tag search across major platforms such as Blogger and Typepad, CMS like Drupal, and other services such as Flickr, Delicious and Socialtext. 	

WordPress, however, lagged behind, and there was pressure from both the open source and WordPress.com communities to add tags to the platform. The native form of classification in WordPress was categories, a hierarchical, top-down mode of classification. A website owner might use it to create their navigational structure, for example. To interact with WordPress, [Technorati picked up the “tag” from the WordPress post’s category](http://lorelle.wordpress.com/2005/09/11/adding-technorati-tags-to-wordpressmu-sites/#comment-113). This was unsatisfactory to lots of users as categories and tags are two different types of classification.

On his blog, [Carthik Sharma wrote](http://carthik.net/blog/vault/2006/02/21/tags-are-not-categories/):	
> categories can be tags but tags cannot be categories. Categories are like the huge signs you see on aisles in supermarkets – “Food”, “Hygiene”, “Frozen” etc, they guide you to sections where you can find what you are looking for. Tags are like the labels on the products themselves.	

Categories and tags have two different, distinct use-cases. Categories are more rigid, whereas tags are a lightweight way of classifying content within a website. There was, of course, a plugin that did the job: WordPress users installed the [Ultimate Tag Warrior](http://neato.co.nz/ultimate-tag-warrior/) plugin (though WordPress.com users could not).	
In 2007, a ticket was [opened by Ryan Boren to support tagging in WordPress core](https://core.trac.wordpress.org/ticket/3723). It was finally agreed that WordPress would have tags. The next step was decide on the database schema. 	
Ryan proposed two database schemas. One of these [created a new table for tags](https://core.trac.wordpress.org/attachment/ticket/3723/tagging.diff), the second put [tags in the current categories database table](https://core.trac.wordpress.org/attachment/ticket/3723/tags.diff). 	

Matt was keen on the second proposal - putting tags in the categories table. He felt that it didn’t make sense to create another table exactly the same as the categories table. In a [comment on trac he wrote](https://core.trac.wordpress.org/ticket/3723#comment:16):

> We already have a ton of rewrite, API, etc infrastructure around categories. Mostly I see tagging as a new interface to the data. On the display side, people want their tags listed separately from their categories, and probably something like a tag cloud function.	
WordPress had already successfully reused tables in the past; for example, posts, pages, and attachments are all stored in the same table, and at that time the categories table also contained link categories. The addition of tagging functionality, from a user’s perspective, enabled them to tag posts, display a list of tags, and display posts with the same tag. What was the point in duplicating the infrastructure when it could be achieved within the current table system?	
The proposal to put tags in the same table as categories [was not supported by many other developers](http://lists.automattic.com/pipermail/wp-hackers/2007-April/011730.html). Categories and tags are two different ways of organising data within WordPress, they argued.	

Arguments against included concerns that the category table would become bloated, and that putting tags in the category table would mean including additional code to keep the two taxonomy types separate. This additional code could introduce new bugs, make it harder to maintain in the future, and make it difficult for developers to extend.	
The proposed single-table taxonomy structure was checked in in changesets [#5110](https://core.trac.wordpress.org/changeset/5110) and [#5111](https://core.trac.wordpress.org/changeset/5111). 	
Much of [April 2007 on wp-hackers](http://lists.automattic.com/pipermail/wp-hackers/2007-April/thread.html) was spent discussing the new database schema for taxonomies. A suggestion that got considerable traction from the community was that categories, link categories, and tags, all be split up into their own individual tables, but no one could come to a consensus. 
Matt posted a new thread on wp-hackers [stating the case for using the categories table](http://lists.automattic.com/pipermail/wp-hackers/2007-April/011930.html). He argued that: 
1. it would perform faster as no additional queries would need to be carried out to support tags. A separate tag table would require at least 2 extra queries on the front end. 
2. that it would provide a better long-term foundation. Tags and categories would be able to share terms (for example the category “dogs” and the tag “dogs”). 
3. That there were no user-facing or plugin-facing problems.	
In the thread, he also proposed a new table, inspired by Drupal’s taxonomy system, specifically for terms within a specific taxonomy. This would allow for terms to be shared amongst taxonomies while having the same ID. Ryan Boren, who had been strongly opposed to the schema which put tags and categories in a new schema, [proposed a new solution](http://lists.automattic.com/pipermail/wp-hackers/2007-April/011991.html), one which enabled individual terms to participate in all taxonomies while keeping the same ID.	
His schema was a compromise. It was a three-table solution, with a table for terms, taxonomies, and objects. The term table would contain the ID, name,  and slug for each term. The term_taxonomy table put the term within the context of a taxonomy. The term_relationships table related a term to a post, link, or another object. This approach would have the advantage of allowing one ID for a term name while using another table to related them to a specific taxonomy. It would be extensible for plugins, which would be able to create their own taxonomy. It would also enable large multisite networks, such as WordPress.com, to create global taxonomies - unified tagging systems in which users of different blogs could share terms within a taxonomy.

Discussion went back and forth, a [new trac ticket was opened up](https://core.trac.wordpress.org/ticket/4189) and a new structure was created based on Ryan’s original proposal. The first table wp_terms, holds basic information about single terms. The wp_term_taxonomy gives the term context by placing it within a taxonomy. The final table, term_relationships relates objects (such as posts or links) to a term_taxonomy_id from the term_taxonomy table.	
As with many WordPress features, tags landed on WordPress.com before they were shipped with WordPress. From the beginning, they caused huge problems. Costs skyrocketed when 10-15% more servers had to be used to enable to support the load that the additional tables and queries brought.[ check with Barry
] “it was slower to be completely honest,” says Matt, “that was a cost that we saw in a very real way on WordPress.com, but also a hidden cost that we did impose on everyone who was doing WordPress in the world.”	
	As well as being a challenging code problem, the activity around the implementation of taxonomies highlighted problems in the development process. Some proposed that the release be delayed, others that the feature be pulled, others still that they ship with the current schema with a view to revising it in the next version. Andy Skelton [raised this point in the WP-Hackers discussion](http://lists.automattic.com/pipermail/wp-hackers/2007-April/011988.html):

> To include a premature feature in an on-time release degrades the quality of the product. I refer to not only the code but the state of the community. Increments are supposed to be in the direction of better, not merely more. Better would be to release on time with a modest set of stable upgrades.	
						
> To block release while the one new feature gets sorted out would be a maladjustment of priorities. If 2.2 seems light on sex appeal, so be it. Better to keep the release date as promised.	
The 120 day release schedule was in danger of being completely blown away by just one issue. Making major architectural changes to core just weeks before a release was contrary to the aims of this new development process. A thread was opened up suggesting that the [release of 2.2 be delayed](http://lists.automattic.com/pipermail/wp-hackers/2007-April/011901.html). The architectural changes were too important to be done in an unsatisfactory way.

As the discussions continued, a decision was made to [delay the 2.2 release](http://lists.automattic.com/pipermail/wp-hackers/2007-April/012090.html), pulling tags out of core and bringing in widgets as a user-facing feature to encourage users to upgrade.


Widgets had been developed for WordPress.com users, built as a way to give people more flexibility over the layout of their blog. They’re blocks of code that can be dragged and dropped into place through the user interface. So blog users could add a calendar, a search bar, or a piece of text, for example, to their sidebar and put them in whatever order they want. In today’s WordPress, features are usually developed by the WordPress core team and Automattic internally develops ones suited to WordPress.com users. Widgets, however, are an example of a feature that was developed for WordPress.com users but that was a perfect fit for all WordPress users. 

Andy Skelton developed the [widget user interface](http://andy.wordpress.com/2006/03/08/widgets-user-interface-and-api/) for WordPress.com. It was hugely popular amongst WordPress.com users and the plugin for WordPress users proved popular too. Launching a feature like this on WordPress.com first meant that it could be tested on lots of different users before making it into core as a feature. Even today, many WordPress features are first tested on WordPress.com users in this way. In the WordPress community [the consensus](https://codex.wordpress.org/IRC_Meetups/2006/June/June07RawLog) was that widgets would make an excellent addition to core, and when WordPress 2.2 looked like it would be feature-light with the absence of the new taxonomy structure, widgets were [brought in as a headline feature](http://wordpress.org/news/2007/05/wordpress-22/).	

The new taxonomy feature made it in to core in WordPress 2.3, and a much compromised and haggled over structure it was. The wrangling over the taxonomy structure has had lasting implications on WordPress developers ever since. In a post in 2013, [Andrew Nacin wrote that](http://make.wordpress.org/core/2013/07/28/potential-roadmap-for-taxonomy-meta-and-post-relationships/) “Hindsight is 20/20, and shared terms are the bane of taxonomies in WordPress.” In the shared term structure, terms are represented by two different IDs: a term ID (which refers to the name and slug) and a term taxonomy ID. A term ID can appear in multiple taxonomies so to properly identify a particular term you must have either the term taxonomy ID or the term ID along with the taxonomy. 	
This is a problem for building features such as term meta. In order to attach metadata to a term, there needs to be only one object identifier - the term taxonomy ID, but the public ID used in the API is the term ID (along with the taxonomy). WordPress has a long-term commitment to maintaining backwards compatibility so just simply creating a new schema isn’t possible. In order to get rid of shared terms, which cause so many problems, the developers need to do it step by step, over a number of major releases, in which shared terms stop being created, they are split apart, slugs and names are moved from wp_terms to wp_term_taxonomy, and the wp_terms table is dropped.	

Not just core developers have [problems with shared terms](http://www.oomphinc.com/blog/2012-01/ruminations-on-the-wordpress-taxonomy-system/). A good example is use of the word orange. A developer might create the taxonomy “Colors” and the taxonomy “Fruit” and user might place the term “orange” in both. Conceptually, this is a different - a colour and a fruit - and they appear in the user interface as different concepts, but the database treats them as the same thing. So if a user made changes to the capitalisation of one, for example, it would also change the capitalisation of the other.

The taxonomy system is an example of something in WordPress that is over engineered and that came as the result of arguments and compromise. When the bazaar model works, it can produce software that people love to use. Where the bazaar model falls down is intractable arguments that result in a compromise that no one is 100% happy with. Despite the arguments over the taxonomy system development of the software continued pretty much on schedule. There were 114 days between WordPress 2.1 and 2.2, and 129 days between the release of 2.2 and 2.3. While delays happened in the future, there was nothing like the long dark year between 2.0 and 2.1.	
